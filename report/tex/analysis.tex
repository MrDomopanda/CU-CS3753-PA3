\section{Analysis}

The ideal scheduling policy in terms of minimizing turnaround time varies depending on the type of process.  For CPU bound processes, it is clear the SCHED\_OTHER algorithm reduced overall run-time, regardless of the system load and in spite of the greater amount of context switching that occurred with this scheduling policy.  I believe this was a result of the scheduler's ability to maximize CPU usage at all levels of system utilization, unlike what was done with either SCHED\_FIFO or SCHED\_RR.  There does appear to be a trend where increasing the number of processes reduces SCHED\_OTHER's advantage.  In fact, it is quite possible that if the system utilization was increased further, SCHED\_OTHER might eventually lose out to the real-time policies.

For I/O bound processes, there is no best scheduler, but SCHED\_OTHER is clearly outperformed by both of the real-time scheduling algorithms.  As system utilization was increased though, the gap between the CFS and real-time algorithms was reduced.  This can most likely be attributed to a more efficient use of the I/O subsystem.  Since SCHED\_RR and SCHED\_FIFO processes have higher priorities than SCHED\_OTHER processes, they are more likely to be given CPU time as soon as they need it which allows them to more quickly make their next I/O request.  As more processes are added to the system, the I/O subsystem spends less time sitting idle.  This idea can also be seen in Figure~\ref{fig:io-thruput-child}; the I/O subsystem is able to support a large amount of data transfer which is not efficiently put to use until enough I/O bound processes are present in the system.  Using the information from the throughput figure does seem to indicate that the SCHED\_RR algorithm is actually the best for completely I/O bound processes.

As for mixed processes, there is simply no best scheduling policy directly in terms of wall time.  The combination of computation and I/O counteract each other and as a result each scheduling algorithm performs essentially identically, although a slight edge may be given to SCHED\_OTHER.  This advantage can also be seen in the throughput results at higher levels of system utilization.  It is entirely likely that when I wrote the mixed benchmark, I unknowingly gave the program more of a CPU bound tendency.  As described above, this would cause the processes to perform best under the SCHED\_OTHER scheduling policy.  I would think that mixed processes would lend themselves to SCHED\_FIFO as the best scheduling policy since that is somewhere between SCHED\_OTHER and SCHED\_RR in terms of priority, but that does not seem to be entirely the case.  

If minimizing time wasted on context switching is desired, SCHED\_FIFO is the ideal scheduling algorithm.  Since a SCHED\_FIFO process can only be preempted by a higher priority process and all processes were given the same priority, the SCHED\_FIFO were almost never preempted (any preemptions were outside the control of my test system setup).
